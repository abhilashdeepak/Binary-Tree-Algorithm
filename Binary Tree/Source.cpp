/*******************************************************************************************
* File Name          : Source.cpp
* Description        : Prog8130 - Program to hold and print a list of string values using 
*					   binary tree by using iteration method
* Author             : Abhilash Deepak
* Date               : 18 October 2021
* Reference			 : https://www.geeksforgeeks.org/print-leaf-nodes-left-right-binary-tree/
********************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

struct nodeData
{
	char name[30];			// character string of the data being stored in the node
	struct nodeData* left;	// pointer to the next node in the tree that is less than current node OR NULL if empty
	struct nodeData* right; // pointer to the next node in the tree that is greater than current node OR NULL if empty
};

struct nodeData* head = NULL; // head of the binary tree

struct sNode 
{
	struct nodeData* temp;
	struct sNode* next;
};

// data inputs generated by last 4 digits of student id
const char* inputData[12] = {
		{ "vyree"},
		{ "pojrb"},
		{ "bfaij"},
		{ "xlmar"},
		{ "irfax"},
		{ "tvfhw"},
		{ "qrema"},
		{ "fqdta"},
		{ "cdxdr"},
		{ "rnvrq"},
		{ "ffucd"},
		{ "gyppd"}
};


// FUNCTION      : create
// DESCRIPTION   : This function creates a new node			   
// PARAMETERS    : newString
// RETURNS       : newNode
struct nodeData* create(const char* newString)
{
	struct nodeData* newNode;
	newNode = (struct nodeData*)malloc(sizeof(struct nodeData));
	if (newNode == NULL) {
		fprintf(stderr, "Memory Allocation Failed\n");
		exit(1);
	}
	strncpy_s(newNode->name, newString, 30);
	newNode->left = newNode->right = NULL;
	return newNode;
}

// FUNCTION      : addToBinaryTree
// DESCRIPTION   : This function will store the data in newnode into a binary tree according to alphabetical order
// PARAMETERS    :  head parameter will be taken as a function
//					newstring - the string that is to be stored in the binary tree in alphabetical order
// RETURNS       :	head

struct nodeData* addToBinaryTree(struct nodeData* head, const char* newString)
{
	if (head == NULL)
	{
		head = create(newString);
	}

	else if (strcmp(newString, head->name) < 0)
	{
		head->left = addToBinaryTree(head->left, newString);
	}

	else if (strcmp(newString, head->name) > 0)
	{
		head->right = addToBinaryTree(head->right, newString);
	}

	return head;
}

// FUNCTION      : push
// DESCRIPTION   : This function pushes the node into stack	   
// PARAMETERS    : top_ref, temp
// RETURNS       : nothing

void push(struct sNode** top_ref, struct nodeData* temp)
{
	struct sNode* new_tNode = (struct sNode*)malloc(sizeof(struct sNode)); // dynamic struct node data allocation
	if (new_tNode == NULL) {
		fprintf(stderr, "Memory Allocation Failed\n");
		exit(1);
	}
	new_tNode->temp = temp;
	new_tNode->next = (*top_ref);
	(*top_ref) = new_tNode;													//assigning head to point to new node created
}

// FUNCTION      : isEmpty
// DESCRIPTION   : To check if top is empty			   
// PARAMETERS    : top
// RETURNS       : returns 1 if NULL else 0

bool isEmpty(struct sNode* top)
{
	return (top == NULL) ? 1 : 0;
}

// FUNCTION      : pop
// DESCRIPTION   : This function pops from the stack			   
// PARAMETERS    : top_ref
// RETURNS       : result

struct nodeData* pop(struct sNode** top_ref)
{
	struct nodeData* res;
	struct sNode* top;
	top = *top_ref;
	res = top->temp;
	*top_ref = top->next;
	free(top);
	return res;
}

// FUNCTION      : newTempNode
// DESCRIPTION   : assigning string to new temporary node			   
// PARAMETERS    : newString
// RETURNS       : nodeData

struct nodeData* newTempNode(const char* newString)
{
	struct nodeData* nodeData = (struct nodeData*)malloc(sizeof(struct nodeData));
	if (nodeData == NULL) {
		fprintf(stderr, "Memory Allocation Failed\n");
		exit(1);
	}
	strncpy_s(nodeData->name, newString, 30);
	nodeData->left = NULL;
	nodeData->right = NULL;
	return (nodeData);
}

// FUNCTION      : printBinaryTree
// DESCRIPTION   : This function prints the required output		   
// PARAMETERS    : head node
// RETURNS       : nothing

void printBinaryTree(struct nodeData* head)
{
	struct nodeData* current = head;
	struct sNode* s = NULL;							// Initializing stack s to NULL
	bool flag = 0;

	while (!flag)
	{
		if (current != NULL)
		{
			push(&s, current);
			current = current->left;				// Traverse left in Binary Tree
		}
		else
		{
			if (!isEmpty(s))
			{
				current = pop(&s);
				printf("%s \n", current->name);		// print left subtree

				current = current->right;			// traverse right 
			}
			else
				flag = 1;							// exiting while loop when flag is 1
		}
	}
}

int main()
{
	int i;
	for (i = 0; i < 12; i++)
		head = addToBinaryTree(head, inputData[i]);		// inserting data into binary tree
	printBinaryTree(head);								// prints in alphabetical order
	return 0;
}
